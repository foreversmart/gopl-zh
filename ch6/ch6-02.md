## 6.2. 基於指針對象的方法

當調用一個函數時，會對其每一個參數值進行拷貝，如果一個函數需要更新一個變量，或者函數的其中一個參數實在太大我們希望能夠避免進行這種默認的拷貝，這種情況下我們就需要用到指針了。對應到我們這里用來更新接收器的對象的方法，當這個接受者變量本身比較大時，我們就可以用其指針而不是對象來聲明方法，如下：

```go
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
```

這個方法的名字是`(*Point).ScaleBy`。這里的括號是必須的；沒有括號的話這個表達式可能會被理解爲`*(Point.ScaleBy)`。

在現實的程序里，一般會約定如果Point這個類有一個指針作爲接收器的方法，那麽所有Point的方法都必須有一個指針接收器，卽使是那些併不需要這個指針接收器的函數。我們在這里打破了這個約定隻是爲了展示一下兩種方法的異同而已。

隻有類型(Point)和指向他們的指針(*Point)，才是可能會出現在接收器聲明里的兩種接收器。此外，爲了避免歧義，在聲明方法時，如果一個類型名本身是一個指針的話，是不允許其出現在接收器中的，比如下面這個例子：

```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

想要調用指針類型方法`(*Point).ScaleBy`，隻要提供一個Point類型的指針卽可，像下面這樣。

```go
r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // "{2, 4}"
```

或者這樣：

```go
p := Point{1, 2}
pptr := &p
pptr.ScaleBy(2)
fmt.Println(p) // "{2, 4}"
```
或者這樣:

```go
p := Point{1, 2}
(&p).ScaleBy(2)
fmt.Println(p) // "{2, 4}"
```

不過後面兩種方法有些笨拙。幸運的是，go語言本身在這種地方會幫到我們。如果接收器p是一個Point類型的變量，併且其方法需要一個Point指針作爲接收器，我們可以用下面這種簡短的寫法：

```go
p.ScaleBy(2)
```

編譯器會隱式地幫我們用&p去調用ScaleBy這個方法。這種簡寫方法隻適用於“變量”，包括struct里的字段比如p.X，以及array和slice內的元素比如perim[0]。我們不能通過一個無法取到地址的接收器來調用指針方法，比如臨時變量的內存地址就無法獲取得到：

```go
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

但是我們可以用一個`*Point`這樣的接收器來調用Point的方法，因爲我們可以通過地址來找到這個變量，隻要用解引用符號`*`來取到該變量卽可。編譯器在這里也會給我們隱式地插入`*`這個操作符，所以下面這兩種寫法等價的：

```Go
pptr.Distance(q)
(*pptr).Distance(q)
```

這里的幾個例子可能讓你有些睏惑，所以我們總結一下：在每一個合法的方法調用表達式中，也就是下面三種情況里的任意一種情況都是可以的：

不論是接收器的實際參數和其接收器的形式參數相同，比如兩者都是類型T或者都是類型`*T`：

```go
Point{1, 2}.Distance(q) //  Point
pptr.ScaleBy(2)         // *Point
```

或者接收器形參是類型T，但接收器實參是類型`*T`，這種情況下編譯器會隱式地爲我們取變量的地址：

```go
p.ScaleBy(2) // implicit (&p)
```

或者接收器形參是類型`*T`，實參是類型T。編譯器會隱式地爲我們解引用，取到指針指向的實際變量：

```go
pptr.Distance(q) // implicit (*pptr)
```

如果類型T的所有方法都是用T類型自己來做接收器(而不是`*T`)，那麽拷貝這種類型的實例就是安全的；調用他的任何一個方法也就會産生一個值的拷貝。比如time.Duration的這個類型，在調用其方法時就會被全部拷貝一份，包括在作爲參數傳入函數的時候。但是如果一個方法使用指針作爲接收器，你需要避免對其進行拷貝，因爲這樣可能會破壞掉該類型內部的不變性。比如你對bytes.Buffer對象進行了拷貝，那麽可能會引起原始對象和拷貝對象隻是别名而已，但實際上其指向的對象是一致的。緊接着對拷貝後的變量進行脩改可能會有讓你意外的結果。

**譯註：** 作者這里説的比較繞，其實有兩點：

1. 不管你的method的receiver是指針類型還是非指針類型，都是可以通過指針/非指針類型進行調用的，編譯器會幫你做類型轉換。
2. 在聲明一個method的receiver該是指針還是非指針類型時，你需要考慮兩方面的內部，第一方面是這個對象本身是不是特别大，如果聲明爲非指針變量時，調用會産生一次拷貝；第二方面是如果你用指針類型作爲receiver，那麽你一定要註意，這種指針類型指向的始終是一塊內存地址，就算你對其進行了拷貝。熟悉C或者C艹的人這里應該很快能明白。

{% include "./ch6-02-1.md" %}
