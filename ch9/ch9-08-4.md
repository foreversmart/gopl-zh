### 9.8.4. Goroutine沒有ID號

在大多數支持多線程的操作繫統和程序語言中，當前的線程都有一個獨特的身份(id)，併且這個身份信息可以以一個普通值的形式被被很容易地獲取到，典型的可以是一個integer或者指針值。這種情況下我們做一個抽象化的thread-local storage(線程本地存儲，多線程編程中不希望其它線程訪問的內容)就很容易，隻需要以線程的id作爲key的一個map就可以解決問題，每一個線程以其id就能從中獲取到值，且和其它線程互不衝突。

goroutine沒有可以被程序員獲取到的身份(id)的概念。這一點是設計上故意而爲之，由於thread-local storage總是會被濫用。比如説，一個web server是用一種支持tls的語言實現的，而非常普遍的是很多函數會去尋找HTTP請求的信息，這代表它們就是去其存儲層(這個存儲層有可能是tls)査找的。這就像是那些過分依賴全局變量的程序一樣，會導致一種非健康的“距離外行爲”，在這種行爲下，一個函數的行爲可能不是由其自己內部的變量所決定，而是由其所運行在的線程所決定。因此，如果線程本身的身份會改變——比如一些worker線程之類的——那麽函數的行爲就會變得神祕莫測。

Go鼓勵更爲簡單的模式，這種模式下參數對函數的影響都是顯式的。這樣不僅使程序變得更易讀，而且會讓我們自由地向一些給定的函數分配子任務時不用擔心其身份信息影響行爲。

你現在應該已經明白了寫一個Go程序所需要的所有語言特性信息。在後面兩章節中，我們會迴顧一些之前的實例和工具，支持我們寫出更大規模的程序：如何將一個工程組織成一繫列的包，如果獲取，構建，測試，性能測試，剖析，寫文檔，併且將這些包分享出去。

